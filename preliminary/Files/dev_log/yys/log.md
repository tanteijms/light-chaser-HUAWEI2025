# log

## 惩罚参数从50减少为25

减少了对转移npu的惩罚时间



再改为5试试

太小了，不如第一次50的惩罚

可能过拟合了



20分更高



15降低了，但仍高于5



## 优化的可能性

对贪心的核心调度逻辑进行优化

原先：

- 在每一轮决策中，会遍历所有的(用户、NPU)组合来寻找最优解。当NPU数量很多时，非常耗时

优化：

- 数据结构：NPU从全部放在扁平的vector里，改为按服务器进行分组，每一个服务器，单独给他维护一个NPU的最小堆，通过std::priority_queue实现。堆顶NPU永远是当前空闲，或者未来最有可能空闲（根据计算出来的最早空闲时间）
- 降低搜索复杂度：原先，在寻找最佳调度任务的时候，对于一个指定的用户和服务器，遍历该服务器上所有的NPU，非常耗时。优化后，只需要查看该优先队列的堆顶元素
- 根据C11/17特性，优化更加简洁、可读性，auto，for的范围循环
  - g++11是GCC编译器的第11个主版本
  - 而C++11 14 17 20是C++语言的规范标准，二者不同
  - g++11是支持C++11/17标准的
- 减少候选服务器的搜索范围：用户网络延迟时影响耗时的一个重要因素，因此要预先计算出该用户通信延迟最低的K的服务器。
  - 不是全部服务器：为了在速度与解的最优性之间做出权衡。防止进行搜索的空间过于大，反而导致性能下降
  - 只要该服务器的网络延迟，大概率很好，就可以，而不需要他是所有服务器里面的最好的一个
  - 因此选择K，这构成一个候选池，可以在保证速度的同时，找到一个足够好的解，并不需要是最好的
  - 这个经验值可以再进行调试与更改
  - 同时结合MIGRATION_PENALTY迁移惩罚，会把用户上一次使用的服务器，也强制加入到候选列表里，尽可能避免迁移惩罚，获得粘性收益
- 代码结构优化：把核心成本的计算逻辑（推理时间、完成时间、迁移惩罚等）提取到一个独立的函数里，让主循环更加简洁
- 迁移惩罚与候选服务器的数量定位常量，方便调整，以及阅读理解
- 优化编译器优化指令，添加pragma GCC优化指令，看看编译层面的性能是否有提升



## 优化守榜

根据题目要求@task.md 。在目前版本的基础上进行优化，题目采用g++11编译器。确保正确的基础上，进行优化@main.cpp 。新的保存在1.0.1/main.cpp里。关于惩罚时间：目前我从50 25 20 5都测了，目前是20是最好的



## 1.0.2v

1. 批处理大小优化

   新增calculate_efficiency和calculate_optimal_batch函数，根据推理速度系数和批处理大小的关系，计算最佳批处理大小

   unordered_map缓存批处理效率计算结果，避免重复计算

2. 用户紧急程度评估

   urgency属性，update_user_urgency函数，根据剩余样本数量与剩余时间的比例，计算用户紧急程度

   优先处理紧急程度高的用户请求

3. NPU负载均衡

   utilization属性，追踪每个NPU的使用率

   计算成本时考虑NPU的使用率，促进负载均衡

4. 动态调度策略

   根据截止时间调整任务优先级，对接近或超过截止时间的任务增加优先级

   deadline_factor动态调整成本计算，确保在截止时间内完成任务

5. NPU选择优化

   按空闲时间对NPU进行排序，优先选择更早空闲的NPU

   减少对NPU的无序遍历，提高查找效率

6. 算法鲁棒性

   当找不到可调度请求时，跳转到下一个可能的调度时间点

   修复可能导致无限循环

7. 最佳迁移惩罚值 = 20



### 用户紧急程度的逻辑











